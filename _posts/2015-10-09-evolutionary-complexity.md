---
id: 219
title: Evolutionary Complexity
date: 2015-10-09T11:09:19+00:00
author: bobm
layout: post
guid: http://robmoff.at/2015/10/09/evolutionary-complexity/
permalink: /2015/10/09/evolutionary-complexity/
categories:
  - information theory
tags:
  - antipatterns
  - blog
---
**In the building industry**
  
****

  * Materials evolve and improve, allowing us to build better buildings.
  * Human needs stay constant.  

**In the software industry**

  * Hardware evolves at an exponential rate
  * Programming languages change somewhat slowly
  * Implementations of PLs change rapidly
  * Libraries for programming languages change rapidly. _(Open Source software is a model of competitive evolution, with successful software attracting users and development talent in order to improve itself faster than unsuccessful competitors. )_
  * The content on the internet changes rapidly
  * Development practices try to keep up
  * Requirements evolve at the pace of business (i.e. fairly rapidly)

Could evolutionary complexity be the main source of difficulty for software engineering?  

**Upshot**

Stable elements that have proved themselves will evolve faster.  This is because elements that create value will receive more evolution.

Evolution is random mutation in nature. It’s little better in our eco-system:  people can be good or bad programmers, all have different ideas about what they want the software to do, and those ideas will live or die in the real world when tested against real situations.

The human brain allows us to model and plan ahead, but at the end of the day, it is limited as a tool and our ideas still have to be tested in the real world.  Can they survive in their niche?

**It’s Not Engineering, Is It?**

We’re not building things to last.  We can’t.  The whole foundation upon which we construct our software is not fixed like the Earth, it is evolving rapidly.  

We can either choose to _minimize dependencies that might change_, which means our software is reliable, but fixed in time and unable to evolve.  Generally, in-house applications will choose the this route. 

-or-

We can try to _keep on top of change_ and keep building our software against new libraries and infrastructure, in the knowledge that this will be fragile and keep us busy.  
  
Wordpress, and operating systems, choose this route. 

**Is there a dichotomy here or not?**
  
****